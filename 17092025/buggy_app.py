#!/usr/bin/env python3
"""
A Deliberately Buggy E-commerce Flask Application for SRE Postmortem Simulation.
This application contains intentional bugs that correspond to the incidents
generated by enhanced_ecommerce_runner.py.
"""
import os
import time
import threading
import logging
from flask import Flask, jsonify, request

app = Flask(__name__)

# --- In-memory "database" and state simulation ---
INVENTORY = {'item_123': 50, 'item_456': 25}
ORDERS = {}
DB_LOCK_INVENTORY = threading.Lock()
DB_LOCK_ORDERS = threading.Lock()

# --- Configuration (or lack thereof) ---
# BUG: Missing environment variables will cause `notification-service` to fail.
SMTP_HOST = os.environ.get('SMTP_HOST')
PAYMENT_API_VERSION = "v2" # Simulates an older version

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# ===============================================
# USER SERVICE
# ===============================================
@app.route('/api/v1/users/login', methods=['POST'])
def user_login():
    # BUG: This endpoint is vulnerable to a simple SQL injection pattern.
    # The 'enhanced_ecommerce_runner' simulates a WAF catching this, 
    # but the vulnerable code is here.
    username = request.json.get('username')
    if "' OR '1'='1" in username:
        logging.error(f"SQL Injection attempt detected for username: {username}")
        return jsonify({"error": "Unauthorized"}), 401
    return jsonify({"message": f"Welcome {username}"})

# ===============================================
# PRODUCT SERVICE
# ===============================================
@app.route('/api/v2/products/search', methods=['GET'])
def product_search():
    # BUG: This simulates a slow query by not using an index (in a real DB)
    # and performing a time-consuming operation.
    query = request.args.get('q')
    logging.info(f"Performing slow search for: {query}")
    time.sleep(3) # Simulates a complex, unoptimized query
    return jsonify([
        {'id': 'item_123', 'name': 'Super Widget'},
        {'id': 'item_456', 'name': 'Mega Gadget'}
    ])

# ===============================================
# ORDER & INVENTORY SERVICES (Interacting)
# ===============================================
@app.route('/api/v1/orders/create', methods=['POST'])
def create_order():
    """
    BUG: This function and `process_inventory_update` can cause a database deadlock.
    This function locks ORDERS then INVENTORY.
    The other function locks INVENTORY then ORDERS.
    If called concurrently, they can deadlock.
    """
    item_id = request.json.get('item_id')
    quantity = request.json.get('quantity')
    order_id = f"ord_{int(time.time())}"

    logging.info(f"Attempting to lock ORDERS for order {order_id}")
    with DB_LOCK_ORDERS:
        logging.info(f"ORDERS locked for {order_id}. Simulating work...")
        time.sleep(0.1)
        logging.info(f"Attempting to lock INVENTORY for order {order_id}")
        with DB_LOCK_INVENTORY:
            logging.info(f"INVENTORY locked for {order_id}")
            if INVENTORY.get(item_id, 0) >= quantity:
                INVENTORY[item_id] -= quantity
                ORDERS[order_id] = {'item': item_id, 'quantity': quantity, 'status': 'created'}
                logging.info(f"Order {order_id} created successfully.")
                return jsonify(ORDERS[order_id]), 201
            else:
                return jsonify({"error": "Out of stock"}), 400

@app.route('/background/inventory/update', methods=['POST'])
def process_inventory_update():
    """
    BUG: Companion function to `create_order` for causing a deadlock.
    This function locks INVENTORY then ORDERS.
    """
    item_id = request.json.get('item_id')
    logging.info(f"BG: Attempting to lock INVENTORY for stock update")
    with DB_LOCK_INVENTORY:
        logging.info("BG: INVENTORY locked. Simulating work...")
        time.sleep(0.1)
        logging.info("BG: Attempting to lock ORDERS for consistency check")
        with DB_LOCK_ORDERS:
            logging.info("BG: ORDERS locked. Both locks acquired.")
            # Simulate checking all orders for the item_id
            time.sleep(0.5)
            logging.info("BG: Consistency check complete.")
            return jsonify({"message": "Inventory check complete"}), 200

# ===============================================
# PAYMENT SERVICE
# ===============================================
@app.route('/api/v3/payments/process', methods=['POST'])
def process_payment():
    # BUG: This endpoint represents a newer version (v3). The order service
    # will try to call an older, non-existent v2 endpoint, causing a
    # version compatibility issue.
    order_id = request.json.get('order_id')
    amount = request.json.get('amount')
    logging.info(f"Processing v3 payment for {order_id} of amount {amount}")
    return jsonify({"status": "paid", "transaction_id": f"txn_{int(time.time())}"})

def call_payment_service_from_order_service(order_id):
    """
    BUG: This function simulates the order-service calling the payment-service
    with an outdated API endpoint.
    """
    if PAYMENT_API_VERSION != "v3":
        logging.error(f"VERSION_COMPATIBILITY_ISSUE: Trying to call /api/{PAYMENT_API_VERSION}/process-payment which is deprecated.")
        # In a real app, this would be a requests.post() call that would fail.
        return False
    return True

# ===============================================
# NOTIFICATION SERVICE
# ===============================================
@app.route('/api/v1/notifications/send', methods=['POST'])
def send_notification():
    # BUG: This function relies on an environment variable that is not set.
    if not SMTP_HOST:
        logging.error("ENVIRONMENT_VARIABLE_MISSING: SMTP_HOST is not set. Cannot send email.")
        return jsonify({"error": "Notification service is misconfigured"}), 500
    
    email = request.json.get('email')
    logging.info(f"Sending notification to {email} via {SMTP_HOST}")
    return jsonify({"message": "Notification sent."})


# ===============================================
# WORKER SERVICE (for performance issues)
# ===============================================
@app.route('/jobs/heavy-computation')
def run_heavy_computation():
    # BUG: This simulates a long-running task that can tie up worker threads,
    # leading to thread pool exhaustion under load.
    logging.info("Starting heavy computation job...")
    time.sleep(10) # Simulates a very long operation
    logging.info("Heavy computation finished.")
    return "Job complete"

if __name__ == '__main__':
    # Running with threaded=True to allow concurrent requests to trigger deadlocks
    app.run(host='0.0.0.0', port=5000, threaded=True, debug=True)
