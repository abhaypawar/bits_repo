Excellent. Now that you have the "brain" (`code_intelligence_graph.graphml`), let's build the tool that your AI agents will use to query it.

This script, `query_graph.py`, implements the **Step 2: Retrieval** logic. It loads the graph and performs the precise, multi-hop queries needed to diagnose an incident. It's designed to be the "tool" that your Root Cause Analysis agent would call.

-----

### The Graph Query and Retrieval Script

Here is the complete code for `query_graph.py`. It simulates exactly the scenario you described: investigating a `database_deadlock`.

**`query_graph.py`**

````python
#!/usr/bin/env python3
"""
Code Intelligence Graph - Online Retrieval Tool

This script loads the pre-built code graph and provides functions to perform
multi-hop traversal queries to diagnose incidents. It simulates the process
an AI agent would use to find the root cause of an issue.

Scenario Simulated:
- Incident: A 'database_deadlock' is reported.
- Goal: Find the culpable functions, their source code, and construct a
  precise prompt for an LLM to perform the final analysis.
"""
import networkx as nx
import os

class GraphQueryEngine:
    """
    A tool for performing intelligent queries on the Code Intelligence Graph.
    This would be provided to a CrewAI agent.
    """
    def __init__(self, graph_path="code_intelligence_graph.graphml"):
        if not os.path.exists(graph_path):
            raise FileNotFoundError(f"Graph file not found: {graph_path}. Please run build_graph.py first.")
        
        print(f"ðŸ§  Loading Code Intelligence Graph from '{graph_path}'...")
        self.graph = nx.read_graphml(graph_path)
        print("   - Graph loaded successfully.")

    def find_functions_causing_error(self, error_type: str) -> list[str]:
        """
        Performs the initial query to find functions linked to a specific error type.
        
        Query: "Find all Function nodes that have a 'CAN_CAUSE' relationship
                with the given ErrorType node."
        """
        culprits = []
        # The graph is directional. Edges go from Function -> ErrorType.
        # So we need to find the predecessors of the error_type node.
        if not self.graph.has_node(error_type):
            return []
            
        for predecessor in self.graph.predecessors(error_type):
            # Ensure the predecessor is a function and the edge type is correct.
            if (self.graph.nodes[predecessor].get('type') == 'Function' and
                self.graph[predecessor][error_type].get('type') == 'CAN_CAUSE'):
                culprits.append(predecessor)
        return culprits

    def find_modified_tables(self, function_names: list[str]) -> dict:
        """
        Performs a multi-hop query to find what database tables a list of
        functions interact with.
        
        Query: "For the given functions, find all DatabaseTable nodes they have
                a 'MODIFIES' relationship with."
        """
        modification_map = {}
        for func_name in function_names:
            modified_tables = []
            if not self.graph.has_node(func_name):
                continue

            for successor in self.graph.successors(func_name):
                if (self.graph.nodes[successor].get('type') == 'DatabaseTable' and
                    self.graph[func_name][successor].get('type') == 'MODIFIES'):
                    modified_tables.append(successor)
            modification_map[func_name] = modified_tables
        return modification_map

    def get_function_source_code(self, function_name: str) -> str:
        """
        Performs targeted retrieval of a function's source code from its node attribute.
        """
        if self.graph.has_node(function_name):
            return self.graph.nodes[function_name].get('source_code', '# Source code not found.')
        return f"# Function '{function_name}' not found in graph."

def run_deadlock_scenario(engine: GraphQueryEngine):
    """
    Simulates the end-to-end retrieval process for a database deadlock incident.
    """
    print("\n" + "="*70)
    print("ðŸš¨ SIMULATING INCIDENT: 'database_deadlock' detected!")
    print("="*70)

    incident_error_type = 'database_deadlock'

    # --- Step A: Initial Query ---
    print("\n[STEP 1/4] ðŸŽ¯ Initial Query: Finding potential culprits...")
    print(f"   - Querying graph: Which functions CAN_CAUSE '{incident_error_type}'?")
    culprit_functions = engine.find_functions_causing_error(incident_error_type)
    
    if not culprit_functions:
        print("   - No functions found associated with this error. Exiting.")
        return

    print(f"   - âœ… Found {len(culprit_functions)} potential culprits: {', '.join(culprit_functions)}")

    # --- Step B: Multi-Hop Query ---
    print("\n[STEP 2/4] ðŸ”— Multi-Hop Query: Understanding resource contention...")
    print("   - Querying graph: Which DatabaseTables do these functions MODIFY?")
    table_modifications = engine.find_modified_tables(culprit_functions)
    
    print("   - âœ… Resource interactions found:")
    for func, tables in table_modifications.items():
        print(f"     - Function '{func}' modifies: {', '.join(tables)}")
        
    # --- Step C: Targeted Retrieval ---
    print("\n[STEP 3/4] ðŸ” Targeted Retrieval: Fetching precise source code...")
    retrieved_code = {}
    for func_name in culprit_functions:
        print(f"   - Retrieving source for '{func_name}'...")
        retrieved_code[func_name] = engine.get_function_source_code(func_name)

    print("   - âœ… Source code retrieved for all culprits.")

    # --- Step D: Construct Augmented Prompt ---
    print("\n[STEP 4/4] ðŸ“ Augmented Prompt Construction...")
    
    prompt_context = "A 'database_deadlock' incident occurred. A Code Intelligence Graph analysis has identified the following functions as the most likely root cause due to their interaction with shared database resources. The relevant source code is provided below."
    
    final_prompt = f"{prompt_context}\n\n"
    final_prompt += "#" * 50 + "\n"
    final_prompt += "# CULPRIT ANALYSIS\n"
    final_prompt += "#" * 50 + "\n\n"

    for func_name, source_code in retrieved_code.items():
        final_prompt += f"--- Function: {func_name} ---\n"
        final_prompt += f"--- Modifies Tables: {', '.join(table_modifications.get(func_name, []))} ---\n"
        final_prompt += "```python\n"
        final_prompt += source_code + "\n"
        final_prompt += "```\n\n"

    final_prompt += "--- TASK ---\n"
    final_prompt += "Analyze the provided source code for these functions. Specifically, examine the order in which they acquire database locks (e.g., `DB_LOCK_ORDERS`, `DB_LOCK_INVENTORY`). Identify the inconsistent lock ordering that is causing the deadlock and describe the exact remediation required to fix it."

    print("   - âœ… Final, surgical prompt for the LLM has been constructed:")
    print("\n" + "-"*70)
    print(final_prompt)
    print("-"*70)

def main():
    """Main execution function."""
    try:
        query_engine = GraphQueryEngine()
        run_deadlock_scenario(query_engine)
    except FileNotFoundError as e:
        print(f"\nERROR: {e}")
        print("Please ensure you have run 'build_graph.py' to generate the graph file first.")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")

if __name__ == "__main__":
    main()

````

-----

### How to Run It

1.  Save the code above as `query_graph.py`.
2.  Make sure the file generated by the previous step, `code_intelligence_graph.graphml`, is in the same directory.
3.  Run the script from your terminal:
    ```bash
    python query_graph.py
    ```

### Expected Output

When you run the script, it will print a detailed, step-by-step log of its investigation, culminating in the final, perfectly-formed prompt for your LLM agent.

````
ðŸ§  Loading Code Intelligence Graph from 'code_intelligence_graph.graphml'...
   - Graph loaded successfully.

======================================================================
ðŸš¨ SIMULATING INCIDENT: 'database_deadlock' detected!
======================================================================

[STEP 1/4] ðŸŽ¯ Initial Query: Finding potential culprits...
   - Querying graph: Which functions CAN_CAUSE 'database_deadlock'?
   - âœ… Found 2 potential culprits: create_order, process_inventory_update

[STEP 2/4] ðŸ”— Multi-Hop Query: Understanding resource contention...
   - Querying graph: Which DatabaseTables do these functions MODIFY?
   - âœ… Resource interactions found:
     - Function 'create_order' modifies: ORDERS, INVENTORY
     - Function 'process_inventory_update' modifies: INVENTORY, ORDERS

[STEP 3/4] ðŸ” Targeted Retrieval: Fetching precise source code...
   - Retrieving source for 'create_order'...
   - Retrieving source for 'process_inventory_update'...
   - âœ… Source code retrieved for all culprits.

[STEP 4/4] ðŸ“ Augmented Prompt Construction...
   - âœ… Final, surgical prompt for the LLM has been constructed:

----------------------------------------------------------------------
A 'database_deadlock' incident occurred. A Code Intelligence Graph analysis has identified the following functions as the most likely root cause due to their interaction with shared database resources. The relevant source code is provided below.

##################################################
# CULPRIT ANALYSIS
##################################################

--- Function: create_order ---
--- Modifies Tables: ORDERS, INVENTORY ---
```python
@app.route('/api/v1/orders/create', methods=['POST'])
def create_order():
    """
    BUG: This function and `process_inventory_update` can cause a database deadlock.
    This function locks ORDERS then INVENTORY.
    The other function locks INVENTORY then ORDERS.
    If called concurrently, they can deadlock.
    """
    item_id = request.json.get('item_id')
    quantity = request.json.get('quantity')
    order_id = f"ord_{int(time.time())}"
    logging.info(f"Attempting to lock ORDERS for order {order_id}")
    with DB_LOCK_ORDERS:
        logging.info(f"ORDERS locked for {order_id}. Simulating work...")
        time.sleep(0.1)
        logging.info(f"Attempting to lock INVENTORY for order {order_id}")
        with DB_LOCK_INVENTORY:
            logging.info(f"INVENTORY locked for {order_id}")
            if INVENTORY.get(item_id, 0) >= quantity:
                INVENTORY[item_id] -= quantity
                ORDERS[order_id] = {'item': item_id, 'quantity': quantity, 'status': 'created'}
                logging.info(f"Order {order_id} created successfully.")
                return jsonify(ORDERS[order_id]), 201
            else:
                return jsonify({'error': 'Out of stock'}), 400
````

\--- Function: process\_inventory\_update ---
\--- Modifies Tables: INVENTORY, ORDERS ---

```python
@app.route('/background/inventory/update', methods=['POST'])
def process_inventory_update():
    """
    BUG: Companion function to `create_order` for causing a deadlock.
    This function locks INVENTORY then ORDERS.
    """
    item_id = request.json.get('item_id')
    logging.info('BG: Attempting to lock INVENTORY for stock update')
    with DB_LOCK_INVENTORY:
        logging.info('BG: INVENTORY locked. Simulating work...')
        time.sleep(0.1)
        logging.info('BG: Attempting to lock ORDERS for consistency check')
        with DB_LOCK_ORDERS:
            logging.info('BG: ORDERS locked. Both locks acquired.')
            time.sleep(0.5)
            logging.info('BG: Consistency check complete.')
            return jsonify({'message': 'Inventory check complete'}), 200
```

## \--- TASK --- Analyze the provided source code for these functions. Specifically, examine the order in which they acquire database locks (e.g., `DB_LOCK_ORDERS`, `DB_LOCK_INVENTORY`). Identify the inconsistent lock ordering that is causing the deadlock and describe the exact remediation required to fix it.

```

You now have a complete, working implementation of your novel RAG strategy. This `GraphQueryEngine` is the bridge between your incident data and your AI agents, enabling them to perform highly effective, human-like reasoning to solve problems.
```
